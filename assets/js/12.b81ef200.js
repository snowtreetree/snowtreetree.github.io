(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{212:function(t,r,s){"use strict";s.r(r);var a=s(0),e=Object(a.a)({},(function(){var t=this,r=t.$createElement,s=t._self._c||r;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"重绘和回流"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#重绘和回流"}},[t._v("#")]),t._v(" 重绘和回流")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),s("p",[t._v("浏览器渲染过程")]),t._v(" "),s("ul",[s("li",[t._v("处理HTML标记，构建DOM树")]),t._v(" "),s("li",[t._v("处理CSS标记，构建CSSOM树")]),t._v(" "),s("li",[t._v("将DOM和CSSDOM合并成渲染树")]),t._v(" "),s("li",[t._v("根据渲染树完成布局，并计算每个节点的集合信息")]),t._v(" "),s("li",[t._v("将节点绘制到屏幕上")])])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/render-tree-construction.png?hl=zh-cn",alt:"过程"}})]),t._v(" "),s("h2",{attrs:{id:"重绘"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#重绘"}},[t._v("#")]),t._v(" 重绘")]),t._v(" "),s("p",[t._v("由于节点的属性发生改变或样式变化影响布局的，称为重绘，例如visibility，color，bgcolor,outline 等。")]),t._v(" "),s("h2",{attrs:{id:"回流（reflow）"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#回流（reflow）"}},[t._v("#")]),t._v(" 回流（reflow）")]),t._v(" "),s("p",[t._v("前面我们通过构造渲染树，我们将可见DOM节点以及它对应的样式结合起来，可是我们还需要计算它们在设备视口(viewport)内的确切位置和大小，这个计算的阶段就是回流。")]),t._v(" "),s("h2",{attrs:{id:"优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#优化"}},[t._v("#")]),t._v(" 优化")]),t._v(" "),s("ul",[s("li",[t._v("减少重绘和回流，或者使用中会代替回流")]),t._v(" "),s("li",[t._v("批量修改（先脱离文档流，然后操作，再恢复）")]),t._v(" "),s("li",[t._v("css3硬件加速（ransform、opacity、filters这些动画不会引起回流重绘）")])])])}),[],!1,null,null,null);r.default=e.exports}}]);